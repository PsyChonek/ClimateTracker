/* tslint:disable */
/* eslint-disable */
/**
 * Climate API
 * API for the Climate project.
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction,
} from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import {
	BASE_PATH,
	COLLECTION_FORMATS,
	BaseAPI,
	RequiredError,
	operationServerMap,
} from './base';

/**
 * Sensor successfully added.
 * @export
 * @interface AddSensorPost200Response
 */
export interface AddSensorPost200Response {
	/**
	 *
	 * @type {string}
	 * @memberof AddSensorPost200Response
	 */
	insertedId?: string;
}
/**
 *
 * @export
 * @interface AddSensorPostRequest
 */
export interface AddSensorPostRequest {
	/**
	 * IP address of the sensor.
	 * @type {string}
	 * @memberof AddSensorPostRequest
	 */
	ip: string;
	/**
	 * Unique ID of the sensor.
	 * @type {string}
	 * @memberof AddSensorPostRequest
	 */
	espId?: string;
}
/**
 *
 * @export
 * @interface AllReadingsGet200ResponseInner
 */
export interface AllReadingsGet200ResponseInner {
	/**
	 *
	 * @type {string}
	 * @memberof AllReadingsGet200ResponseInner
	 */
	sensorID?: string;
	/**
	 *
	 * @type {number}
	 * @memberof AllReadingsGet200ResponseInner
	 */
	temperature?: number;
	/**
	 *
	 * @type {number}
	 * @memberof AllReadingsGet200ResponseInner
	 */
	humidity?: number;
	/**
	 *
	 * @type {string}
	 * @memberof AllReadingsGet200ResponseInner
	 */
	timestamp?: string;
}
/**
 *
 * @export
 * @interface AllSensorsGet200ResponseInner
 */
export interface AllSensorsGet200ResponseInner {
	/**
	 *
	 * @type {string}
	 * @memberof AllSensorsGet200ResponseInner
	 */
	_id?: string;
	/**
	 *
	 * @type {string}
	 * @memberof AllSensorsGet200ResponseInner
	 */
	ip?: string;
	/**
	 *
	 * @type {string}
	 * @memberof AllSensorsGet200ResponseInner
	 */
	espId?: string;
	/**
	 *
	 * @type {string}
	 * @memberof AllSensorsGet200ResponseInner
	 */
	displayName?: string;
	/**
	 *
	 * @type {number}
	 * @memberof AllSensorsGet200ResponseInner
	 */
	temperatureOffset?: number;
	/**
	 *
	 * @type {number}
	 * @memberof AllSensorsGet200ResponseInner
	 */
	humidityOffset?: number;
}
/**
 * Reading successfully added.
 * @export
 * @interface NewReadingPost200Response
 */
export interface NewReadingPost200Response {
	/**
	 *
	 * @type {string}
	 * @memberof NewReadingPost200Response
	 */
	insertedId?: string;
}
/**
 *
 * @export
 * @interface NewReadingPostRequest
 */
export interface NewReadingPostRequest {
	/**
	 * Unique ID of the sensor.
	 * @type {string}
	 * @memberof NewReadingPostRequest
	 */
	sensorID: string;
	/**
	 * Temperature reading in Celsius.
	 * @type {number}
	 * @memberof NewReadingPostRequest
	 */
	temperature: number;
	/**
	 * Humidity reading in percentage.
	 * @type {number}
	 * @memberof NewReadingPostRequest
	 */
	humidity: number;
	/**
	 * Timestamp of the reading.
	 * @type {string}
	 * @memberof NewReadingPostRequest
	 */
	timestamp?: string;
}
/**
 * Sensor successfully updated.
 * @export
 * @interface SensorPatch200Response
 */
export interface SensorPatch200Response {
	/**
	 *
	 * @type {number}
	 * @memberof SensorPatch200Response
	 */
	modifiedCount?: number;
}
/**
 *
 * @export
 * @interface SensorPatchRequest
 */
export interface SensorPatchRequest {
	/**
	 * Unique ID
	 * @type {string}
	 * @memberof SensorPatchRequest
	 */
	_id?: string;
	/**
	 * Unique ID of the sensor.
	 * @type {string}
	 * @memberof SensorPatchRequest
	 */
	espId?: string;
	/**
	 * Display name of the sensor.
	 * @type {string}
	 * @memberof SensorPatchRequest
	 */
	displayName?: string;
	/**
	 * Temperature offset value.
	 * @type {number}
	 * @memberof SensorPatchRequest
	 */
	temperatureOffset?: number;
	/**
	 * Humidity offset value.
	 * @type {number}
	 * @memberof SensorPatchRequest
	 */
	humidityOffset?: number;
}

/**
 * ReadingsApi - axios parameter creator
 * @export
 */
export const ReadingsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Retrieve all readings within a specific date range.
		 * @summary Get all readings
		 * @param {string} [fromDate] Start date for the range.
		 * @param {string} [toDate] End date for the range.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		allReadingsGet: async (
			fromDate?: string,
			toDate?: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/allReadings`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (fromDate !== undefined) {
				localVarQueryParameter['fromDate'] =
					(fromDate as any) instanceof Date
						? (fromDate as any).toISOString().substring(0, 10)
						: fromDate;
			}

			if (toDate !== undefined) {
				localVarQueryParameter['toDate'] =
					(toDate as any) instanceof Date
						? (toDate as any).toISOString().substring(0, 10)
						: toDate;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Endpoint to add a new sensor reading to the database.
		 * @summary Add a new reading
		 * @param {NewReadingPostRequest} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newReadingPost: async (
			body?: NewReadingPostRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/newReading`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				body,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * ReadingsApi - functional programming interface
 * @export
 */
export const ReadingsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ReadingsApiAxiosParamCreator(configuration);
	return {
		/**
		 * Retrieve all readings within a specific date range.
		 * @summary Get all readings
		 * @param {string} [fromDate] Start date for the range.
		 * @param {string} [toDate] End date for the range.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async allReadingsGet(
			fromDate?: string,
			toDate?: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<AllReadingsGet200ResponseInner>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.allReadingsGet(
				fromDate,
				toDate,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['ReadingsApi.allReadingsGet']?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Endpoint to add a new sensor reading to the database.
		 * @summary Add a new reading
		 * @param {NewReadingPostRequest} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async newReadingPost(
			body?: NewReadingPostRequest,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<NewReadingPost200Response>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.newReadingPost(
				body,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['ReadingsApi.newReadingPost']?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * ReadingsApi - factory interface
 * @export
 */
export const ReadingsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = ReadingsApiFp(configuration);
	return {
		/**
		 * Retrieve all readings within a specific date range.
		 * @summary Get all readings
		 * @param {string} [fromDate] Start date for the range.
		 * @param {string} [toDate] End date for the range.
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		allReadingsGet(
			fromDate?: string,
			toDate?: string,
			options?: RawAxiosRequestConfig
		): AxiosPromise<Array<AllReadingsGet200ResponseInner>> {
			return localVarFp
				.allReadingsGet(fromDate, toDate, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Endpoint to add a new sensor reading to the database.
		 * @summary Add a new reading
		 * @param {NewReadingPostRequest} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		newReadingPost(
			body?: NewReadingPostRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<NewReadingPost200Response> {
			return localVarFp
				.newReadingPost(body, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * ReadingsApi - object-oriented interface
 * @export
 * @class ReadingsApi
 * @extends {BaseAPI}
 */
export class ReadingsApi extends BaseAPI {
	/**
	 * Retrieve all readings within a specific date range.
	 * @summary Get all readings
	 * @param {string} [fromDate] Start date for the range.
	 * @param {string} [toDate] End date for the range.
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ReadingsApi
	 */
	public allReadingsGet(
		fromDate?: string,
		toDate?: string,
		options?: RawAxiosRequestConfig
	) {
		return ReadingsApiFp(this.configuration)
			.allReadingsGet(fromDate, toDate, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Endpoint to add a new sensor reading to the database.
	 * @summary Add a new reading
	 * @param {NewReadingPostRequest} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ReadingsApi
	 */
	public newReadingPost(
		body?: NewReadingPostRequest,
		options?: RawAxiosRequestConfig
	) {
		return ReadingsApiFp(this.configuration)
			.newReadingPost(body, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * SensorsApi - axios parameter creator
 * @export
 */
export const SensorsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * Add a new sensor to the database with its IP and port.
		 * @summary Add a new sensor
		 * @param {AddSensorPostRequest} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addSensorPost: async (
			body?: AddSensorPostRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/addSensor`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				body,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Retrieve all sensors stored in the database.
		 * @summary Get all sensors
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		allSensorsGet: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/allSensors`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Update the display name and offsets for a sensor.
		 * @summary Update sensor information
		 * @param {SensorPatchRequest} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		sensorPatch: async (
			body?: SensorPatchRequest,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/sensor`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: 'PATCH',
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter['Content-Type'] = 'application/json';

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				body,
				localVarRequestOptions,
				configuration
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * SensorsApi - functional programming interface
 * @export
 */
export const SensorsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = SensorsApiAxiosParamCreator(configuration);
	return {
		/**
		 * Add a new sensor to the database with its IP and port.
		 * @summary Add a new sensor
		 * @param {AddSensorPostRequest} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addSensorPost(
			body?: AddSensorPostRequest,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<AddSensorPost200Response>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.addSensorPost(
				body,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['SensorsApi.addSensorPost']?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Retrieve all sensors stored in the database.
		 * @summary Get all sensors
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async allSensorsGet(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<AllSensorsGet200ResponseInner>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.allSensorsGet(options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['SensorsApi.allSensorsGet']?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Update the display name and offsets for a sensor.
		 * @summary Update sensor information
		 * @param {SensorPatchRequest} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async sensorPatch(
			body?: SensorPatchRequest,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<SensorPatch200Response>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.sensorPatch(
				body,
				options
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap['SensorsApi.sensorPatch']?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * SensorsApi - factory interface
 * @export
 */
export const SensorsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SensorsApiFp(configuration);
	return {
		/**
		 * Add a new sensor to the database with its IP and port.
		 * @summary Add a new sensor
		 * @param {AddSensorPostRequest} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addSensorPost(
			body?: AddSensorPostRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<AddSensorPost200Response> {
			return localVarFp
				.addSensorPost(body, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Retrieve all sensors stored in the database.
		 * @summary Get all sensors
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		allSensorsGet(
			options?: RawAxiosRequestConfig
		): AxiosPromise<Array<AllSensorsGet200ResponseInner>> {
			return localVarFp
				.allSensorsGet(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Update the display name and offsets for a sensor.
		 * @summary Update sensor information
		 * @param {SensorPatchRequest} [body]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		sensorPatch(
			body?: SensorPatchRequest,
			options?: RawAxiosRequestConfig
		): AxiosPromise<SensorPatch200Response> {
			return localVarFp
				.sensorPatch(body, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * SensorsApi - object-oriented interface
 * @export
 * @class SensorsApi
 * @extends {BaseAPI}
 */
export class SensorsApi extends BaseAPI {
	/**
	 * Add a new sensor to the database with its IP and port.
	 * @summary Add a new sensor
	 * @param {AddSensorPostRequest} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SensorsApi
	 */
	public addSensorPost(
		body?: AddSensorPostRequest,
		options?: RawAxiosRequestConfig
	) {
		return SensorsApiFp(this.configuration)
			.addSensorPost(body, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Retrieve all sensors stored in the database.
	 * @summary Get all sensors
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SensorsApi
	 */
	public allSensorsGet(options?: RawAxiosRequestConfig) {
		return SensorsApiFp(this.configuration)
			.allSensorsGet(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Update the display name and offsets for a sensor.
	 * @summary Update sensor information
	 * @param {SensorPatchRequest} [body]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SensorsApi
	 */
	public sensorPatch(
		body?: SensorPatchRequest,
		options?: RawAxiosRequestConfig
	) {
		return SensorsApiFp(this.configuration)
			.sensorPatch(body, options)
			.then((request) => request(this.axios, this.basePath));
	}
}
